<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Event Balance Editor</title>
  <style>
    :root {
      --bg: #1a1a2e;
      --surface: #16213e;
      --surface-hover: #1f3460;
      --border: #0f3460;
      --text: #e8e8e8;
      --text-muted: #888;
      --accent: #e94560;
      --success: #4ade80;
      --warning: #fbbf24;
      --danger: #ef4444;
    }
    
    * { box-sizing: border-box; margin: 0; padding: 0; }
    
    body {
      font-family: 'Segoe UI', system-ui, sans-serif;
      background: var(--bg);
      color: var(--text);
      padding: 20px;
      min-height: 100vh;
    }
    
    h1 {
      color: var(--accent);
      margin-bottom: 10px;
      font-size: 1.8rem;
    }
    
    .toolbar {
      display: flex;
      gap: 10px;
      margin-bottom: 20px;
      flex-wrap: wrap;
      align-items: center;
    }
    
    button {
      background: var(--accent);
      color: white;
      border: none;
      padding: 8px 16px;
      border-radius: 6px;
      cursor: pointer;
      font-size: 0.9rem;
      transition: opacity 0.2s;
    }
    
    button:hover { opacity: 0.8; }
    button.secondary { background: var(--border); }
    
    .event-selector {
      background: var(--surface);
      border: 1px solid var(--border);
      color: var(--text);
      padding: 8px 12px;
      border-radius: 6px;
      font-size: 0.9rem;
      min-width: 200px;
    }
    
    .targets {
      display: flex;
      gap: 20px;
      margin-bottom: 20px;
      background: var(--surface);
      padding: 10px 15px;
      border-radius: 8px;
      font-size: 0.85rem;
    }
    
    .targets span { color: var(--text-muted); }
    .targets strong { color: var(--success); }
    
    .event-card {
      background: var(--surface);
      border-radius: 12px;
      padding: 20px;
      margin-bottom: 20px;
    }
    
    .event-header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      margin-bottom: 15px;
      border-bottom: 1px solid var(--border);
      padding-bottom: 10px;
    }
    
    .event-name {
      font-size: 1.3rem;
      color: var(--accent);
    }
    
    .event-desc {
      color: var(--text-muted);
      font-size: 0.85rem;
      font-style: italic;
    }
    
    .outcome-grid {
      display: grid;
      grid-template-columns: 150px repeat(4, 1fr);
      gap: 8px;
    }
    
    .outcome-header {
      font-weight: bold;
      padding: 8px;
      text-align: center;
      color: var(--text-muted);
      font-size: 0.8rem;
    }
    
    .approach-label {
      padding: 8px;
      font-size: 0.85rem;
      display: flex;
      align-items: center;
    }
    
    .outcome-cell {
      background: var(--bg);
      border-radius: 8px;
      padding: 10px;
      min-height: 80px;
      position: relative;
    }
    
    .cell-value {
      position: absolute;
      top: 5px;
      right: 8px;
      font-size: 0.75rem;
      font-weight: bold;
      padding: 2px 6px;
      border-radius: 4px;
    }
    
    .cell-value.good { background: #166534; color: #4ade80; }
    .cell-value.ok { background: #854d0e; color: #fbbf24; }
    .cell-value.bad { background: #991b1b; color: #fca5a5; }
    
    .badges {
      display: flex;
      flex-wrap: wrap;
      gap: 4px;
      margin-top: 20px;
    }
    
    .badge {
      display: inline-flex;
      align-items: center;
      gap: 4px;
      padding: 4px 8px;
      border-radius: 4px;
      font-size: 0.75rem;
      cursor: pointer;
      transition: all 0.2s;
    }
    
    .badge:hover { filter: brightness(1.2); }
    
    .badge.positive { background: #166534; color: #4ade80; }
    .badge.negative { background: #991b1b; color: #fca5a5; }
    .badge.neutral { background: #1e3a5f; color: #93c5fd; }
    .badge.special { background: #6b21a8; color: #d8b4fe; }
    
    .badge .effect-text { cursor: pointer; }
    .badge .effect-text:hover { text-decoration: underline; }
    
    .badge .remove {
      margin-left: 2px;
      opacity: 0.6;
      font-size: 0.9rem;
    }
    
    .badge .remove:hover { opacity: 1; }
    
    .add-btn {
      background: var(--border);
      color: var(--text-muted);
      border: 1px dashed var(--text-muted);
      padding: 4px 10px;
      border-radius: 4px;
      font-size: 0.75rem;
      cursor: pointer;
    }
    
    .add-btn:hover { background: var(--surface-hover); color: var(--text); }
    
    /* Dropdown menu */
    .dropdown {
      position: absolute;
      background: var(--surface);
      border: 1px solid var(--border);
      border-radius: 8px;
      padding: 8px 0;
      z-index: 100;
      min-width: 200px;
      max-height: 300px;
      overflow-y: auto;
      box-shadow: 0 4px 20px rgba(0,0,0,0.5);
    }
    
    .dropdown-item {
      padding: 8px 12px;
      cursor: pointer;
      font-size: 0.85rem;
    }
    
    .dropdown-item:hover { background: var(--surface-hover); }
    
    .dropdown-category {
      padding: 6px 12px;
      font-size: 0.7rem;
      color: var(--text-muted);
      text-transform: uppercase;
      font-weight: bold;
    }
    
    /* Modal */
    .modal-overlay {
      position: fixed;
      top: 0;
      left: 0;
      right: 0;
      bottom: 0;
      background: rgba(0,0,0,0.7);
      display: flex;
      align-items: center;
      justify-content: center;
      z-index: 200;
    }
    
    .modal {
      background: var(--surface);
      border-radius: 12px;
      padding: 20px;
      min-width: 350px;
    }
    
    .modal h3 { margin-bottom: 15px; color: var(--accent); }
    
    .modal label {
      display: block;
      margin-bottom: 5px;
      color: var(--text-muted);
      font-size: 0.85rem;
    }
    
    .modal input, .modal select {
      width: 100%;
      padding: 10px;
      margin-bottom: 10px;
      background: var(--bg);
      border: 1px solid var(--border);
      border-radius: 6px;
      color: var(--text);
      font-size: 1rem;
    }
    
    .modal input:focus, .modal select:focus {
      outline: none;
      border-color: var(--accent);
    }
    
    .modal-buttons {
      display: flex;
      gap: 10px;
      justify-content: flex-end;
      margin-top: 15px;
    }
    
    .formula-preview {
      background: var(--bg);
      padding: 10px;
      border-radius: 6px;
      margin-bottom: 10px;
      font-size: 0.9rem;
    }
    
    .formula-preview .value {
      color: var(--success);
      font-weight: bold;
    }
    
    .formula-examples {
      font-size: 0.75rem;
      color: var(--text-muted);
      margin-bottom: 10px;
    }
    
    .hidden { display: none !important; }
  </style>
</head>
<body>
  <h1>‚öñÔ∏è Event Balance Editor</h1>
  
  <div class="targets">
    <span>Targets ‚Üí </span>
    <span>CS: <strong>+10</strong></span>
    <span>S: <strong>+3</strong></span>
    <span>F: <strong>-3</strong></span>
    <span>CF: <strong>-10</strong></span>
  </div>
  
  <div class="toolbar">
    <select class="event-selector" id="eventSelector">
      <option value="">-- Select Event --</option>
    </select>
    <button onclick="prevEvent()">‚Üê Prev</button>
    <button onclick="nextEvent()">Next ‚Üí</button>
    <button class="secondary" onclick="exportCSV()">üì• Export CSV</button>
    <button class="secondary" onclick="document.getElementById('importInput').click()">üì§ Import CSV</button>
    <input type="file" id="importInput" accept=".csv" style="display:none" onchange="importCSV(event)">
  </div>
  
  <div id="eventContainer"></div>
  
  <div id="dropdown" class="dropdown hidden"></div>
  
  <!-- Edit Formula Modal -->
  <div id="modalOverlay" class="modal-overlay hidden">
    <div class="modal">
      <h3>Edit Effect</h3>
      <div id="modalContent"></div>
      <div class="modal-buttons">
        <button class="secondary" onclick="closeModal()">Cancel</button>
        <button onclick="saveModal()">Save</button>
      </div>
    </div>
  </div>

  <script>
    // Effect type definitions (base effects without dice)
    // invertSign: true means +X in effect string = negative value (like Unrest: +Unrest is bad)
    const EFFECT_TYPES = {
      'Unrest': { baseValue: 2, invertSign: true },
      'Gold': { baseValue: 1 },
      'Food': { baseValue: 1 },
      'Materials': { baseValue: 1 },
      'Lumber': { baseValue: 1 },
      'Ore': { baseValue: 1 },
      'Stone': { baseValue: 1 },
      'Faction': { baseValue: 3 },
      'Fame': { baseValue: 5 },
      'Convert': { baseValue: 1 },
      'Pardon': { baseValue: 1 },
      'innocents': { baseValue: 2, alwaysNegative: true },
    };
    
    // Fixed effects (no formula editing)
    const FIXED_EFFECTS = {
      '+1 Structure': 5,
      'Damage 1 structure': -5,
      'Damage 2 structures': -10,
      '+1 Worksite': 5,
      'Lose Worksite': -5,
      'Settlement +1 Level': 5,
      'Settlement -1 Level': -5,
      'Claim 1 hex': 5,
      'Lose 1 hex': -5,
      'Army Well Trained': 5,
      'Army equip': 5,
      'Army fatigued': -3,
      'Army enfeebled': -5,
      'No effect': 0,
      '+Ongoing Unrest': -3,
      '+Ongoing Gold': 3,
      '-1d3 Gold cost': 2,
    };
    
    // Calculate average value of a dice formula
    function calculateDiceAverage(formula) {
      if (!formula) return 0;
      formula = formula.toLowerCase().trim();
      
      // Handle integer
      if (/^-?\d+$/.test(formula)) {
        return parseInt(formula);
      }
      
      // Handle dice like 1d4, 2d6, etc.
      const diceMatch = formula.match(/^(\d*)d(\d+)$/);
      if (diceMatch) {
        const count = parseInt(diceMatch[1] || '1');
        const sides = parseInt(diceMatch[2]);
        return count * (sides + 1) / 2;
      }
      
      // Handle dice + modifier like 1d4+2, 2d6-1
      const diceModMatch = formula.match(/^(\d*)d(\d+)\s*([+-])\s*(\d+)$/);
      if (diceModMatch) {
        const count = parseInt(diceModMatch[1] || '1');
        const sides = parseInt(diceModMatch[2]);
        const op = diceModMatch[3];
        const mod = parseInt(diceModMatch[4]);
        const diceAvg = count * (sides + 1) / 2;
        return op === '+' ? diceAvg + mod : diceAvg - mod;
      }
      
      return 0;
    }
    
    // Parse an effect string into components
    function parseEffect(effectStr) {
      // Check if it's a fixed effect
      if (FIXED_EFFECTS.hasOwnProperty(effectStr)) {
        return { type: 'fixed', effect: effectStr, value: FIXED_EFFECTS[effectStr] };
      }
      
      // Match patterns like "+1d4 Unrest", "-2d3 Gold", "Convert 1d4", "Faction +1"
      
      // Pattern: +/-XdY Type (e.g., +1d4 Unrest, -2d3 Gold)
      const dicePattern = /^([+-]?)(\d*d\d+(?:[+-]\d+)?)\s+(.+)$/i;
      let match = effectStr.match(dicePattern);
      if (match) {
        const sign = match[1] || '+';
        const formula = match[2];
        const type = match[3];
        const avg = calculateDiceAverage(formula);
        const typeDef = EFFECT_TYPES[type];
        const baseValue = typeDef ? typeDef.baseValue : 1;
        const isNegative = sign === '-' || (typeDef && typeDef.alwaysNegative);
        const value = avg * baseValue * (isNegative ? -1 : 1);
        return { type: 'dice', sign, formula, effectType: type, value, avg };
      }
      
      // Pattern: Type +/-X (e.g., Faction +1, Faction -2)
      const typeFirstPattern = /^(.+?)\s+([+-])(\d+)$/;
      match = effectStr.match(typeFirstPattern);
      if (match) {
        const type = match[1];
        const sign = match[2];
        const num = parseInt(match[3]);
        const typeDef = EFFECT_TYPES[type];
        const baseValue = typeDef ? typeDef.baseValue : 1;
        const value = num * baseValue * (sign === '-' ? -1 : 1);
        return { type: 'static', effectType: type, sign, num, value };
      }
      
      // Pattern: Type XdY (e.g., Convert 1d4, Pardon 1d3)
      const typeDicePattern = /^(.+?)\s+(\d*d\d+(?:[+-]\d+)?)(?:\s+\((.+)\))?$/i;
      match = effectStr.match(typeDicePattern);
      if (match) {
        const type = match[1];
        const formula = match[2];
        const suffix = match[3] || '';
        const avg = calculateDiceAverage(formula);
        const typeDef = EFFECT_TYPES[type];
        const baseValue = typeDef ? typeDef.baseValue : 1;
        const isNegative = typeDef && typeDef.alwaysNegative;
        const value = avg * baseValue * (isNegative ? -1 : 1);
        return { type: 'typeDice', effectType: type, formula, suffix, value, avg };
      }
      
      // Pattern: +/-X Type (e.g., +1 Fame, -1 Fame)
      const staticPattern = /^([+-])(\d+)\s+(.+)$/;
      match = effectStr.match(staticPattern);
      if (match) {
        const sign = match[1];
        const num = parseInt(match[2]);
        const type = match[3];
        const typeDef = EFFECT_TYPES[type];
        const baseValue = typeDef ? typeDef.baseValue : 1;
        const value = num * baseValue * (sign === '-' ? -1 : 1);
        return { type: 'static', sign, num, effectType: type, value };
      }
      
      return { type: 'unknown', effect: effectStr, value: 0 };
    }
    
    // Build effect string from components
    function buildEffectString(parsed, newFormula) {
      if (parsed.type === 'fixed') return parsed.effect;
      
      if (parsed.type === 'dice') {
        const sign = parsed.sign === '-' || (EFFECT_TYPES[parsed.effectType] && EFFECT_TYPES[parsed.effectType].alwaysNegative) ? '-' : '+';
        return `${sign}${newFormula} ${parsed.effectType}`;
      }
      
      if (parsed.type === 'static') {
        if (parsed.effectType === 'Faction' || parsed.effectType === 'Fame') {
          return `${parsed.effectType} ${parsed.sign}${newFormula}`;
        }
        return `${parsed.sign}${newFormula} ${parsed.effectType}`;
      }
      
      if (parsed.type === 'typeDice') {
        const suffix = parsed.suffix ? ` (${parsed.suffix})` : '';
        return `${parsed.effectType} ${newFormula}${suffix}`;
      }
      
      return parsed.effect;
    }
    
    // Calculate value from effect string
    function getEffectValue(effectStr) {
      const parsed = parseEffect(effectStr);
      return parsed.value;
    }
    
    // Get effect type (for badge color)
    function getEffectType(effectStr) {
      const parsed = parseEffect(effectStr);
      if (parsed.value > 0) return 'positive';
      if (parsed.value < 0) return 'negative';
      if (effectStr.includes('Convert') || effectStr.includes('Pardon')) return 'neutral';
      if (effectStr.includes('Army') || effectStr.includes('Fame')) return 'special';
      return 'neutral';
    }
    
    let events = [];
    let currentEventIndex = 0;
    let currentEditContext = null;
    
    // Parse CSV
    function parseCSV(csv) {
      const lines = csv.trim().split('\n');
      const result = [];
      let currentEvent = null;
      
      for (let i = 1; i < lines.length; i++) {
        const values = parseCSVLine(lines[i]);
        if (values[0]) {
          currentEvent = {
            name: values[0],
            description: values[10] || '',
            status: values[11] || '',
            approaches: []
          };
          result.push(currentEvent);
        }
        if (currentEvent) {
          currentEvent.approaches.push({
            name: values[1],
            cs: parseEffects(values[2]),
            s: parseEffects(values[4]),
            f: parseEffects(values[6]),
            cf: parseEffects(values[8])
          });
        }
      }
      return result;
    }
    
    function parseCSVLine(line) {
      const result = [];
      let current = '';
      let inQuotes = false;
      for (let i = 0; i < line.length; i++) {
        const char = line[i];
        if (char === '"') {
          inQuotes = !inQuotes;
        } else if (char === ',' && !inQuotes) {
          result.push(current.trim());
          current = '';
        } else {
          current += char;
        }
      }
      result.push(current.trim());
      return result;
    }
    
    function parseEffects(str) {
      if (!str || str === 'No effect') return [];
      return str.split(',').map(s => s.trim()).filter(s => s);
    }
    
    function calculateValue(effects) {
      return effects.reduce((sum, effect) => sum + getEffectValue(effect), 0);
    }
    
    function getValueClass(value, target) {
      const diff = Math.abs(value - target);
      if (diff <= 1) return 'good';
      if (diff <= 3) return 'ok';
      return 'bad';
    }
    
    function renderEvent(event) {
      const container = document.getElementById('eventContainer');
      const outcomes = ['cs', 's', 'f', 'cf'];
      const outcomeLabels = ['Critical Success', 'Success', 'Failure', 'Critical Failure'];
      const targets = { cs: 10, s: 3, f: -3, cf: -10 };
      
      let html = `
        <div class="event-card">
          <div class="event-header">
            <div>
              <div class="event-name">${event.name}</div>
              <div class="event-desc">${event.description}</div>
            </div>
            <div class="event-status">${event.status}</div>
          </div>
          <div class="outcome-grid">
            <div class="outcome-header"></div>
            ${outcomeLabels.map(l => `<div class="outcome-header">${l}</div>`).join('')}
      `;
      
      event.approaches.forEach((approach, approachIdx) => {
        html += `<div class="approach-label">${approach.name}</div>`;
        
        outcomes.forEach(outcome => {
          const effects = approach[outcome];
          const value = calculateValue(effects);
          const target = targets[outcome];
          const valueClass = getValueClass(value, target);
          
          html += `
            <div class="outcome-cell" data-approach="${approachIdx}" data-outcome="${outcome}">
              <div class="cell-value ${valueClass}">${value >= 0 ? '+' : ''}${value}</div>
              <div class="badges">
                ${effects.map((effect, effectIdx) => {
                  const effectType = getEffectType(effect);
                  const parsed = parseEffect(effect);
                  const isEditable = parsed.type !== 'fixed' && parsed.type !== 'unknown';
                  return `<span class="badge ${effectType}" data-effect="${effectIdx}">
                    <span class="effect-text" ${isEditable ? `onclick="editEffect(${approachIdx}, '${outcome}', ${effectIdx})"` : ''}>${effect}</span>
                    <span class="remove" onclick="removeEffect(${approachIdx}, '${outcome}', ${effectIdx})">√ó</span>
                  </span>`;
                }).join('')}
                <button class="add-btn" onclick="showAddMenu(event, ${approachIdx}, '${outcome}')">+ Add</button>
              </div>
            </div>
          `;
        });
      });
      
      html += '</div></div>';
      container.innerHTML = html;
    }
    
    function editEffect(approachIdx, outcome, effectIdx) {
      const effect = events[currentEventIndex].approaches[approachIdx][outcome][effectIdx];
      const parsed = parseEffect(effect);
      
      if (parsed.type === 'fixed' || parsed.type === 'unknown') return;
      
      currentEditContext = { approachIdx, outcome, effectIdx, effect, parsed };
      
      let currentFormula = '';
      if (parsed.type === 'dice') currentFormula = parsed.formula;
      else if (parsed.type === 'static') currentFormula = String(parsed.num);
      else if (parsed.type === 'typeDice') currentFormula = parsed.formula;
      
      const modalContent = document.getElementById('modalContent');
      modalContent.innerHTML = `
        <div class="formula-examples">
          Examples: 1d4, 2d6, 1d4+2, 3, 1d3-1
        </div>
        <label>Effect Type: <strong>${parsed.effectType || effect}</strong></label>
        <label for="formulaInput">Formula:</label>
        <input type="text" id="formulaInput" value="${currentFormula}" placeholder="e.g., 1d4, 2d6, 3" autofocus>
        <div class="formula-preview">
          New Effect: <span id="previewEffect">${effect}</span><br>
          Value: <span class="value" id="previewValue">${parsed.value}</span>
        </div>
      `;
      
      document.getElementById('modalOverlay').classList.remove('hidden');
      
      const input = document.getElementById('formulaInput');
      input.focus();
      input.select();
      input.addEventListener('input', updateFormulaPreview);
      input.addEventListener('keydown', (e) => {
        if (e.key === 'Enter') saveModal();
        if (e.key === 'Escape') closeModal();
      });
    }
    
    function updateFormulaPreview() {
      const input = document.getElementById('formulaInput');
      const newFormula = input.value.trim();
      const parsed = currentEditContext.parsed;
      
      const newEffect = buildEffectString(parsed, newFormula);
      const newValue = getEffectValue(newEffect);
      
      document.getElementById('previewEffect').textContent = newEffect;
      document.getElementById('previewValue').textContent = newValue >= 0 ? '+' + newValue : newValue;
    }
    
    function saveModal() {
      if (!currentEditContext) return;
      
      const input = document.getElementById('formulaInput');
      const newFormula = input.value.trim();
      const parsed = currentEditContext.parsed;
      
      const newEffect = buildEffectString(parsed, newFormula);
      
      events[currentEventIndex].approaches[currentEditContext.approachIdx][currentEditContext.outcome][currentEditContext.effectIdx] = newEffect;
      
      renderEvent(events[currentEventIndex]);
      saveToStorage();
      closeModal();
    }
    
    function closeModal() {
      document.getElementById('modalOverlay').classList.add('hidden');
      currentEditContext = null;
    }
    
    // Effect categories for add menu
    const EFFECT_CATEGORIES = {
      'Unrest': ['+1d2 Unrest', '+1d3 Unrest', '+1d4 Unrest', '+2d4 Unrest', '-1d2 Unrest', '-1d3 Unrest', '-1d4 Unrest', '-2d4 Unrest', '+Ongoing Unrest'],
      'Gold': ['+1d2 Gold', '+1d3 Gold', '+1d4 Gold', '+2d4 Gold', '+3d4 Gold', '-1d2 Gold', '-1d3 Gold', '-1d4 Gold', '+Ongoing Gold'],
      'Food': ['+1d2 Food', '+1d3 Food', '+1d4 Food', '+2d4 Food', '-1d2 Food', '-1d3 Food', '-1d4 Food'],
      'Materials': ['+1d2 Materials', '+1d3 Materials', '+1d4 Materials', '+2d4 Materials', '+1d2 Lumber', '+1d3 Lumber', '+1d4 Lumber', '+2d4 Lumber', '-1d2 Lumber', '-1d4 Lumber', '+1d4 Ore'],
      'Faction': ['Faction +1', 'Faction +2', 'Faction -1', 'Faction -2'],
      'Fame': ['+1 Fame', '+2 Fame', '-1 Fame'],
      'Prison': ['Convert 1d2', 'Convert 1d3', 'Convert 1d4', 'Convert 2d4', 'Pardon 1d2', 'Pardon 1d3', 'Pardon 1d4', '+1d2 innocents', '+1d3 innocents', '+1d4 innocents'],
      'Structures': ['+1 Structure', 'Damage 1 structure', 'Damage 2 structures', '+1 Worksite', 'Lose Worksite', 'Settlement +1 Level', 'Settlement -1 Level'],
      'Territory': ['Claim 1 hex', 'Lose 1 hex'],
      'Army': ['Army Well Trained', 'Army equip', 'Army fatigued', 'Army enfeebled'],
      'Special': ['No effect', '-1d3 Gold cost'],
    };
    
    function showAddMenu(e, approachIdx, outcome) {
      e.stopPropagation();
      const dropdown = document.getElementById('dropdown');
      
      let html = '';
      for (const [category, effects] of Object.entries(EFFECT_CATEGORIES)) {
        html += `<div class="dropdown-category">${category}</div>`;
        effects.forEach(effect => {
          const value = getEffectValue(effect);
          const valueStr = value >= 0 ? `+${value}` : value;
          html += `<div class="dropdown-item" onclick="addEffect(${approachIdx}, '${outcome}', '${effect}')">${effect} <span style="color:var(--text-muted)">(${valueStr})</span></div>`;
        });
      }
      
      dropdown.innerHTML = html;
      dropdown.style.left = e.pageX + 'px';
      dropdown.style.top = e.pageY + 'px';
      dropdown.classList.remove('hidden');
    }
    
    function addEffect(approachIdx, outcome, effect) {
      events[currentEventIndex].approaches[approachIdx][outcome].push(effect);
      renderEvent(events[currentEventIndex]);
      hideDropdown();
      saveToStorage();
    }
    
    function removeEffect(approachIdx, outcome, effectIdx) {
      events[currentEventIndex].approaches[approachIdx][outcome].splice(effectIdx, 1);
      renderEvent(events[currentEventIndex]);
      saveToStorage();
    }
    
    function hideDropdown() {
      document.getElementById('dropdown').classList.add('hidden');
    }
    
    document.addEventListener('click', (e) => {
      if (!e.target.closest('.dropdown') && !e.target.closest('.add-btn')) {
        hideDropdown();
      }
    });
    
    function updateEventSelector() {
      const selector = document.getElementById('eventSelector');
      selector.innerHTML = events.map((e, i) => 
        `<option value="${i}" ${i === currentEventIndex ? 'selected' : ''}>${e.name}</option>`
      ).join('');
    }
    
    document.getElementById('eventSelector').addEventListener('change', (e) => {
      currentEventIndex = parseInt(e.target.value);
      renderEvent(events[currentEventIndex]);
    });
    
    function prevEvent() {
      if (currentEventIndex > 0) {
        currentEventIndex--;
        updateEventSelector();
        renderEvent(events[currentEventIndex]);
      }
    }
    
    function nextEvent() {
      if (currentEventIndex < events.length - 1) {
        currentEventIndex++;
        updateEventSelector();
        renderEvent(events[currentEventIndex]);
      }
    }
    
    function saveToStorage() {
      localStorage.setItem('eventBalanceData', JSON.stringify(events));
    }
    
    function loadFromStorage() {
      const saved = localStorage.getItem('eventBalanceData');
      if (saved) {
        events = JSON.parse(saved);
        return true;
      }
      return false;
    }
    
    function exportCSV() {
      const outcomes = ['cs', 's', 'f', 'cf'];
      let csv = 'Name,Approach,Critical Success,CS Val,Success,S Val,Failure,F Val,Critical Failure,CF Val,Description,Status\n';
      
      events.forEach(event => {
        event.approaches.forEach((approach, idx) => {
          const name = idx === 0 ? event.name : '';
          const desc = idx === 0 ? event.description : '';
          const status = idx === 0 ? event.status : '';
          
          const csVal = calculateValue(approach.cs);
          const sVal = calculateValue(approach.s);
          const fVal = calculateValue(approach.f);
          const cfVal = calculateValue(approach.cf);
          
          const csStr = approach.cs.join(', ') || 'No effect';
          const sStr = approach.s.join(', ') || 'No effect';
          const fStr = approach.f.join(', ') || 'No effect';
          const cfStr = approach.cf.join(', ') || 'No effect';
          
          csv += `${name},"${approach.name}","${csStr}",${csVal},"${sStr}",${sVal},"${fStr}",${fVal},"${cfStr}",${cfVal},"${desc}",${status}\n`;
        });
      });
      
      const blob = new Blob([csv], { type: 'text/csv' });
      const url = URL.createObjectURL(blob);
      const a = document.createElement('a');
      a.href = url;
      a.download = 'EVENT_BALANCE_TABLE.csv';
      a.click();
    }
    
    function importCSV(e) {
      const file = e.target.files[0];
      if (file) {
        const reader = new FileReader();
        reader.onload = (e) => {
          events = parseCSV(e.target.result);
          currentEventIndex = 0;
          updateEventSelector();
          renderEvent(events[currentEventIndex]);
          saveToStorage();
        };
        reader.readAsText(file);
      }
    }
    
    // Initialize
    if (!loadFromStorage()) {
      fetch('EVENT_BALANCE_TABLE.csv')
        .then(r => r.text())
        .then(csv => {
          events = parseCSV(csv);
          updateEventSelector();
          renderEvent(events[currentEventIndex]);
        })
        .catch(() => {
          alert('Please import the CSV file using the Import button.');
        });
    } else {
      updateEventSelector();
      renderEvent(events[currentEventIndex]);
    }
  </script>
</body>
</html>
