#!/usr/bin/env python3
"""
Generate TypeScript type definitions from Kingdom data sources.
This ensures type safety and keeps code in sync with data.
"""

import json
import os
from pathlib import Path
from typing import Dict, List, Any, Set

def get_unique_values_from_events(events: List[Dict[str, Any]], field: str) -> Set[str]:
    """Extract unique values from a specific field across all events."""
    values = set()
    for event in events:
        if field in event:
            if isinstance(event[field], list):
                values.update(event[field])
            else:
                values.add(event[field])
    return values

def get_skill_names(events: List[Dict[str, Any]]) -> Set[str]:
    """Extract all unique skill names from events."""
    skills = set()
    for event in events:
        if 'skills' in event and event['skills']:
            for skill in event['skills']:
                if isinstance(skill, dict) and 'skill' in skill:
                    skills.add(skill['skill'])
    return skills

def get_selector_names(events: List[Dict[str, Any]]) -> Set[str]:
    """Extract all unique selector names from event modifiers."""
    selectors = set()
    for event in events:
        if 'effects' in event:
            for outcome_type in ['criticalSuccess', 'success', 'failure', 'criticalFailure']:
                if outcome_type in event['effects']:
                    outcome = event['effects'][outcome_type]
                    if 'modifiers' in outcome:
                        for modifier in outcome['modifiers']:
                            if 'selector' in modifier:
                                selectors.add(modifier['selector'])
    return selectors

def generate_event_types(events_path: str) -> str:
    """Generate TypeScript types for events."""
    
    # Load all events
    with open(events_path, 'r', encoding='utf-8') as f:
        events = json.load(f)
    
    # Extract unique values
    traits = get_unique_values_from_events(events, 'traits')
    skills = get_skill_names(events)
    selectors = get_selector_names(events)
    locations = get_unique_values_from_events(events, 'location')
    
    # Build TypeScript content
    ts_content = """// Auto-generated TypeScript types from Kingdom data
// Generated by scripts/generate-types.py
// DO NOT EDIT MANUALLY - Run 'npm run generate-types' to update

/**
 * Kingdom Event skill with description
 */
export interface EventSkill {
  skill: KingdomSkill;
  description: string;
}

/**
 * All available kingdom skills
 */
export type KingdomSkill = 
"""
    
    # Add skill types
    skill_lines = [f'  | "{skill}"' for skill in sorted(skills)]
    ts_content += '\n'.join(skill_lines) + ';\n\n'
    
    # Add trait types
    ts_content += """/**
 * Event trait types
 */
export type EventTrait = 
"""
    trait_lines = [f'  | "{trait}"' for trait in sorted(traits)]
    ts_content += '\n'.join(trait_lines) + ';\n\n'
    
    # Add selector types
    ts_content += """/**
 * Modifier selector types (what the modifier affects)
 */
export type ModifierSelector = 
"""
    selector_lines = [f'  | "{selector}"' for selector in sorted(selectors)]
    ts_content += '\n'.join(selector_lines) + ';\n\n'
    
    # Add location types
    ts_content += """/**
 * Event location types
 */
export type EventLocation = 
"""
    location_lines = [f'  | "{location}"' for location in sorted(locations)]
    ts_content += '\n'.join(location_lines) + ';\n\n'
    
    # Add main event interfaces
    ts_content += """/**
 * Event tier types (events use 'event', incidents vary)
 */
export type EventTier = 'event' | 'minor' | 'moderate' | 'major' | number;

/**
 * Resource types that can be modified
 */
export type ResourceType = 'gold' | 'food' | 'lumber' | 'stone' | 'ore' | 'luxuries' | 'unrest' | 'fame' | 'imprisoned_unrest' | 'damage_structure';

/**
 * Modifier duration types (can be string or number for turn count)
 */
export type ModifierDuration = 'immediate' | 'ongoing' | 'permanent' | number;

/**
 * Event modifier details (unified format)
 */
export interface EventModifier {
  resource: ResourceType;
  value: number | string;  // Can be number or dice formula (e.g., "1d4")
  type?: string;  // Optional modifier type (e.g., "untyped")
  duration?: ModifierDuration;  // Optional duration
}

/**
 * Event outcome with message and modifiers
 */
export interface EventOutcome {
  msg: string;
  endsEvent?: boolean;
  modifiers?: EventModifier[];
  manualEffects?: string[];  // Optional manual effects to display
}

/**
 * Event effects (outcomes for different degrees of success)
 */
export interface EventEffects {
  criticalSuccess?: EventOutcome;
  success?: EventOutcome;
  failure?: EventOutcome;
  criticalFailure?: EventOutcome;
}

/**
 * Kingdom Event data structure (simplified, unified format)
 */
export interface KingdomEvent {
  id: string;
  name: string;  // Display name for UI
  tier: EventTier;
  description: string;
  skills?: EventSkill[];
  effects: EventEffects;
  traits?: EventTrait[];  // Event traits (beneficial, dangerous, ongoing)
}

/**
 * Kingdom Incident (same structure as event)
 */
export interface KingdomIncident extends KingdomEvent {
  tier: 'minor' | 'moderate' | 'major';
}

/**
 * Type guard to check if an object is a KingdomEvent
 */
export function isKingdomEvent(obj: any): obj is KingdomEvent {
  return (
    typeof obj === 'object' &&
    typeof obj.id === 'string' &&
    typeof obj.name === 'string' &&
    typeof obj.description === 'string' &&
    typeof obj.effects === 'object'
  );
}

/**
 * Helper to generate display name from event ID
 */
export function getEventDisplayName(event: KingdomEvent): string {
  return event.id
    .split('-')
    .map(word => word.charAt(0).toUpperCase() + word.slice(1))
    .join(' ');
}
"""
    
    return ts_content

def generate_incident_types(incidents_path: str) -> str:
    """Generate TypeScript types for incidents.
    
    Note: Incidents use the same structure as events, so we re-export most types.
    """
    
    # Build TypeScript content (no need to extract severity - it's redundant with tier)
    ts_content = """// Auto-generated TypeScript types for Kingdom Incidents
// Generated by scripts/generate-types.py
// DO NOT EDIT MANUALLY - Run 'npm run generate-types' to update

/**
 * NOTE: Incidents use the same core structure as Events.
 * We re-export event types and add incident-specific interface.
 * 
 * Incidents use the EventTier type (minor, moderate, major) from events.
 * The JSON has a redundant 'severity' field which we ignore in favor of 'tier'.
 */

// Re-export all event types for use with incidents
export type {
  EventSkill,
  KingdomSkill,
  EventTrait,
  EventLocation,
  EventTier,
  ResourceType,
  ModifierDuration,
  EventModifier,
  EventOutcome,
  EventEffects,
  KingdomEvent
} from './events';

/**
 * Kingdom Incident (same structure as event)
 * 
 * Incidents are similar to events but:
 * - Always triggered by high Unrest (not random)
 * - Have severity tiers (minor, moderate, major) via EventTier
 * - Use same skill/effect structure as events
 */
export interface KingdomIncident {
  id: string;
  name: string;  // Display name for UI
  tier: 'minor' | 'moderate' | 'major';
  description: string;
  skills?: EventSkill[];
  effects: EventEffects;
  traits?: EventTrait[];  // Event traits (beneficial, dangerous, ongoing)
}

/**
 * Type guard to check if an object is a KingdomIncident
 */
export function isKingdomIncident(obj: any): obj is KingdomIncident {
  return (
    typeof obj === 'object' &&
    typeof obj.id === 'string' &&
    typeof obj.name === 'string' &&
    typeof obj.description === 'string' &&
    typeof obj.tier === 'string' &&
    typeof obj.effects === 'object'
  );
}

/**
 * Helper to generate display name from incident ID
 */
export function getIncidentDisplayName(incident: KingdomIncident): string {
  return incident.id
    .split('-')
    .map(word => word.charAt(0).toUpperCase() + word.slice(1))
    .join(' ');
}
"""
    
    return ts_content

def generate_action_types(actions_path: str) -> str:
    """Generate TypeScript types for player actions."""
    
    # Load all actions
    with open(actions_path, 'r', encoding='utf-8') as f:
        actions = json.load(f)
    
    # Extract unique values
    categories = set()
    skills = set()
    
    for action in actions:
        if 'category' in action:
            categories.add(action['category'])
        if 'skills' in action:
            for skill in action['skills']:
                if isinstance(skill, dict) and 'skill' in skill:
                    skills.add(skill['skill'])
    
    # Build TypeScript content
    ts_content = """// Auto-generated TypeScript types for Player Actions
// Generated by scripts/generate-types.py
// DO NOT EDIT MANUALLY - Run 'npm run generate-types' to update

import type { KingdomSkill } from './events';

/**
 * Player action skill with description
 */
export interface ActionSkill {
  skill: KingdomSkill;
  description: string;
}

/**
 * Action category types
 */
export type ActionCategory = 
"""
    
    # Add category types
    category_lines = [f'  | "{cat}"' for cat in sorted(categories)]
    ts_content += '\n'.join(category_lines) + ';\n\n'
    
    # Add main action interfaces
    ts_content += """/**
 * Action effect modifiers (simple key-value pairs)
 */
export interface ActionModifiers {
  [key: string]: number | boolean | string;
}

/**
 * Action effect with description and modifiers
 */
export interface ActionEffect {
  description: string;
  modifiers?: ActionModifiers;
}

/**
 * Action effects for different outcomes
 */
export interface ActionEffects {
  criticalSuccess?: ActionEffect;
  success?: ActionEffect;
  failure?: ActionEffect;
  criticalFailure?: ActionEffect;
}

/**
 * Resource costs for an action
 */
export interface ActionCosts {
  gold?: number;
  food?: number;
  lumber?: number;
  stone?: number;
  ore?: number;
  luxuries?: number;
  resources?: number;
}

/**
 * Player Action data structure
 */
export interface PlayerAction {
  id: string;
  name: string;
  category: ActionCategory;
  brief: string;
  description: string;
  skills?: ActionSkill[];
  effects: ActionEffects;
  failureCausesUnrest?: boolean;
  costs?: ActionCosts;
  special?: string;
}

/**
 * Type guard to check if an object is a PlayerAction
 */
export function isPlayerAction(obj: any): obj is PlayerAction {
  return (
    typeof obj === 'object' &&
    typeof obj.id === 'string' &&
    typeof obj.name === 'string' &&
    typeof obj.category === 'string' &&
    typeof obj.effects === 'object'
  );
}
"""
    
    return ts_content

def main():
    """Generate all TypeScript types from data sources."""
    
    # Paths
    project_root = Path.cwd()
    dist_dir = project_root / 'dist'
    types_dir = project_root / 'src' / 'types'
    
    print("=" * 60)
    print("GENERATING TYPESCRIPT TYPES FROM DATA")
    print("=" * 60)
    print()
    
    # Ensure types directory exists
    types_dir.mkdir(parents=True, exist_ok=True)
    
    # Generate event types
    events_path = dist_dir / 'events.json'
    if events_path.exists():
        print("📝 Generating event types...")
        event_types = generate_event_types(str(events_path))
        
        # Write event types
        event_types_path = types_dir / 'events.ts'
        with open(event_types_path, 'w', encoding='utf-8') as f:
            f.write(event_types)
        print(f"  ✓ Written to {event_types_path.relative_to(project_root)}")
    else:
        print(f"  ⚠️ Events file not found at {events_path}")
    
    # Generate action types
    actions_path = dist_dir / 'player-actions.json'
    if actions_path.exists():
        print("📝 Generating player action types...")
        action_types = generate_action_types(str(actions_path))
        
        # Write action types
        action_types_path = types_dir / 'player-actions.ts'
        with open(action_types_path, 'w', encoding='utf-8') as f:
            f.write(action_types)
        print(f"  ✓ Written to {action_types_path.relative_to(project_root)}")
    else:
        print(f"  ⚠️ Actions file not found at {actions_path}")
    
    # Generate incident types
    incidents_path = dist_dir / 'incidents.json'
    if incidents_path.exists():
        print("📝 Generating incident types...")
        incident_types = generate_incident_types(str(incidents_path))
        
        # Write incident types
        incident_types_path = types_dir / 'incidents.ts'
        with open(incident_types_path, 'w', encoding='utf-8') as f:
            f.write(incident_types)
        print(f"  ✓ Written to {incident_types_path.relative_to(project_root)}")
    else:
        print(f"  ⚠️ Incidents file not found at {incidents_path}")
    
    print()
    print("=" * 60)
    print("SUMMARY")
    print("=" * 60)
    print("✅ TypeScript types generated from data sources")
    print()
    print("The following files have been created/updated:")
    print("  - src/types/events.ts")
    print("  - src/types/player-actions.ts")
    print("  - src/types/incidents.ts")
    print()
    print("These types are auto-generated and should not be edited manually.")
    print("Run 'npm run generate-types' to regenerate after data changes.")

if __name__ == "__main__":
    main()
